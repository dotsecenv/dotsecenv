package gpg

import (
	"fmt"
	"strings"
)

// KeyAlgorithm represents a supported key algorithm for generation.
type KeyAlgorithm string

const (
	AlgoED25519 KeyAlgorithm = "ED25519"
	AlgoRSA4096 KeyAlgorithm = "RSA4096"
	AlgoP384    KeyAlgorithm = "P384"
	AlgoP521    KeyAlgorithm = "P521"
)

// AlgorithmInfo contains the GPG batch template parameters for an algorithm.
type AlgorithmInfo struct {
	KeyType   string // GPG Key-Type value
	KeyCurve  string // GPG Key-Curve value (for ECC/EdDSA)
	KeyLength int    // GPG Key-Length value (for RSA)
	// Subkey for encryption
	SubkeyType   string // GPG Subkey-Type value
	SubkeyCurve  string // GPG Subkey-Curve value (for ECC)
	SubkeyLength int    // GPG Subkey-Length value (for RSA)
	// For algorithm validation
	AlgoFamily string // "ECC", "EdDSA", or "RSA"
	Curve      string // Curve name for validation (e.g., "P-384", "Ed25519")
	Bits       int    // Bit length for validation
}

// SupportedAlgorithms maps algorithm flag values to their GPG parameters.
var SupportedAlgorithms = map[KeyAlgorithm]AlgorithmInfo{
	AlgoED25519: {
		KeyType:     "eddsa",
		KeyCurve:    "ed25519",
		SubkeyType:  "ecdh",
		SubkeyCurve: "cv25519",
		AlgoFamily:  "EdDSA",
		Curve:       "Ed25519",
		Bits:        255,
	},
	AlgoRSA4096: {
		KeyType:      "RSA",
		KeyLength:    4096,
		SubkeyType:   "RSA",
		SubkeyLength: 4096,
		AlgoFamily:   "RSA",
		Bits:         4096,
	},
	AlgoP384: {
		KeyType:     "ecdsa",
		KeyCurve:    "nistp384",
		SubkeyType:  "ecdh",
		SubkeyCurve: "nistp384",
		AlgoFamily:  "ECC",
		Curve:       "P-384",
		Bits:        384,
	},
	AlgoP521: {
		KeyType:     "ecdsa",
		KeyCurve:    "nistp521",
		SubkeyType:  "ecdh",
		SubkeyCurve: "nistp521",
		AlgoFamily:  "ECC",
		Curve:       "P-521",
		Bits:        521,
	},
}

// DefaultAlgorithm is the default algorithm for key generation (P384 for FIPS compliance).
const DefaultAlgorithm = AlgoP384

// KeyTemplateOptions holds options for GPG key template generation.
type KeyTemplateOptions struct {
	NoPassphrase bool // Add %no-protection for CI/automation (no passphrase prompt)
}

// ParseAlgorithm parses an algorithm string into a KeyAlgorithm.
// Returns an error if the algorithm is not recognized.
func ParseAlgorithm(algo string) (KeyAlgorithm, error) {
	upper := strings.ToUpper(algo)
	switch upper {
	case "ED25519":
		return AlgoED25519, nil
	case "RSA4096":
		return AlgoRSA4096, nil
	case "P384":
		return AlgoP384, nil
	case "P521":
		return AlgoP521, nil
	default:
		return "", fmt.Errorf("unsupported algorithm: %s\nSupported algorithms: ED25519, RSA4096, P384, P521", algo)
	}
}

// GetAlgorithmForValidation returns the algorithm string used for config validation.
// This format matches what IsAlgorithmAllowed expects.
func GetAlgorithmForValidation(algo KeyAlgorithm) (string, int) {
	info, ok := SupportedAlgorithms[algo]
	if !ok {
		return "", 0
	}

	switch info.AlgoFamily {
	case "EdDSA":
		return fmt.Sprintf("EdDSA %s", info.Curve), info.Bits
	case "ECC":
		return fmt.Sprintf("ECC %s", info.Curve), info.Bits
	case "RSA":
		return "RSA", info.Bits
	default:
		return "", 0
	}
}

// GenerateKeyTemplate generates a GPG batch file template for key generation.
// Pass nil for opts to use defaults (with passphrase prompt, 2y expiration).
func GenerateKeyTemplate(algo KeyAlgorithm, name, email string, opts *KeyTemplateOptions) (string, error) {
	info, ok := SupportedAlgorithms[algo]
	if !ok {
		return "", fmt.Errorf("unsupported algorithm: %s", algo)
	}

	var sb strings.Builder

	// Header comment
	sb.WriteString("# Code generated by `dotsecenv identity create`. DO NOT EDIT.\n")
	sb.WriteString("# https://dotsecenv.com\n")

	// Key type
	sb.WriteString(fmt.Sprintf("Key-Type: %s\n", info.KeyType))

	// Curve or length depending on algorithm
	if info.KeyCurve != "" {
		sb.WriteString(fmt.Sprintf("Key-Curve: %s\n", info.KeyCurve))
	}
	if info.KeyLength > 0 {
		sb.WriteString(fmt.Sprintf("Key-Length: %d\n", info.KeyLength))
	}

	// Key usage - signing only for primary key
	sb.WriteString("Key-Usage: sign\n")

	// Encryption subkey
	sb.WriteString(fmt.Sprintf("Subkey-Type: %s\n", info.SubkeyType))
	if info.SubkeyCurve != "" {
		sb.WriteString(fmt.Sprintf("Subkey-Curve: %s\n", info.SubkeyCurve))
	}
	if info.SubkeyLength > 0 {
		sb.WriteString(fmt.Sprintf("Subkey-Length: %d\n", info.SubkeyLength))
	}
	sb.WriteString("Subkey-Usage: encrypt\n")

	// Cipher/hash preferences (exclude weak algorithms like 3DES)
	sb.WriteString("Preferences: AES256 SHA512 Uncompressed\n")

	// User identity
	sb.WriteString(fmt.Sprintf("Name-Real: %s\n", name))
	sb.WriteString(fmt.Sprintf("Name-Email: %s\n", email))

	// Expiration (2 years by default)
	sb.WriteString("Expire-Date: 2y\n")

	// No passphrase protection (for CI/automation)
	if opts != nil && opts.NoPassphrase {
		sb.WriteString("%no-protection\n")
	}

	// Commit the key generation
	sb.WriteString("%commit\n")

	return sb.String(), nil
}

// GetSupportedAlgorithmsString returns a human-readable list of supported algorithms.
func GetSupportedAlgorithmsString() string {
	return "Supported algorithms: ED25519, RSA4096, P384 (default), P521"
}
